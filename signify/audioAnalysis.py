#!/usr/bin/env python3

#  __________                         __  .__                              .__     
#  \______   \_____    ______ _______/  |_|  |_________  ____  __ __  ____ |  |__  
#   |     ___/\__  \  /  ___//  ___/\   __\  |  \_  __ \/  _ \|  |  \/ ___\|  |  \ 
#   |    |     / __ \_\___ \ \___ \  |  | |   Y  \  | \(  <_> )  |  / /_/  >   Y  \
#   |____|    (____  /____  >____  > |__| |___|  /__|   \____/|____/\___  /|___|  /
#                  \/     \/     \/            \/                  /_____/      \/ 

"""Signify module to pass audio generated by the Clip Manager to the designated
audio output device. This module also produces analyise data on the incoming audio
stream, which can be sent to the arduino to modulate the LEDs."""

# Primary research sources:
# - https://stackoverflow.com/questions/66964597/python-gui-freezing-problem-of-thread-using-tkinter-and-sounddevice


from multiprocessing import Event
import time
import queue
import random
import logging
import threading
import numpy as np
import sounddevice as sd

RHISTORY = 2
DEFAULT_CONF = {
    "enabled":True,
    "loopback_return":1,
    "hw_loop_output":0,
    "sample_rate":48000,
    "buffer":4096 }

sd.default.device = (1,0)
sd.default.channels = (1,1)
sd.default.samplerate = DEFAULT_CONF['sample_rate']

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


class Stream(threading.Thread):
    """A PulseAudio loopback stream to analyse the audio\
    and output to the hardware device.\n
    Supply the audio portion of `config.json`, i.e. `config['audio']`."""
    def __init__(self, config=None):
        super().__init__()
        logger.debug(f'Streaming module detected the following devices:\n{sd.query_devices()}')
        if config is None:
            config = DEFAULT_CONF
        else:
            self.active = True
            self.input = config['loopback_return']
            self.output = config['hw_loop_output']
            self.sample_rate = config['sample_rate']
            self.buffer = config['buffer']
        sd.default.channels = 1
        sd.default.device = (self.input, self.output)
        sd.default.samplerate = self.sample_rate
        self.event = None
        self.stream = None
        self.streaming = True
        self.y_roll = np.random.rand(RHISTORY, self.buffer) / 1e16
        self.amp = 0
        self.amp_q = queue.Queue(maxsize=1)
        self.peak = 0
        self.peak_q = queue.Queue(maxsize=1)
        logger.debug('Audio passthrough module initialised.')


    def run(self):
        """Threaded routine that starts a PortAudio stream for piping Signifier\
        audio to the hardware audio output.\n
        Also executes audio analysis during the callback and updates audio\
        descriptors available from `get_descriptors()` function."""
        logger.debug('Starting loopback stream and analysis thread...')
        if self.stream is not None:
            self.stream.close()
        self.event = threading.Event()
        with sd.Stream(device=(self.input, self.output),
                   samplerate=self.sample_rate, channels=1,
                   callback=self.callback) as self.stream:
        # with sd.Stream(callback=self.callback) as self.stream:
        #     self.event.wait()
            try:
                sd.Stream.abort(self)
                print("ABORTED STREAM!")
            except AttributeError:
                sd.CallbackAbort()
                print("ABORTED CALLBACK!")
                self.streaming = False


    def terminate(self):
        """Requests that the Stream thread aborts current buffer processing\
        and provides an `event.set()` call to terminate the thread."""
        print()
        logger.info(f'Stopping audio streaming thread...')
        self.streaming = False
        self.event.set()
        sd.sleep(10)
        self.stream.abort()


    def callback(self, indata, outdata, frames, time, status):
        """The primary function called by the Streaming thread. This function\
        calculates the amplitude of the input signal, then streams it to the\
        output audio device."""
        if self.streaming:
            if status:
                logger.debug(status)
            outdata[:] = indata
            self.cat = np.concatenate(indata)
            self.y_roll[:-1] = self.y_roll[1:]
            self.y_roll[-1, :] = np.copy(indata[0])
            self.y_data = np.concatenate(self.y_roll, axis=0).astype(np.float32)
            self.amp = np.max(np.abs(self.y_data))
            self.peak = max(self.peak, np.max(np.abs(indata)))
            try:
                self.amp_q.put_nowait(self.amp)
            except queue.Full:
                pass
            try:
                self.peak_q.put_nowait(self.peak)
            except queue.Full:
                pass


    def get_descriptors(self) -> dict:
        """Return a dictionary with audio analysis values returned from thread."""
        try:
            self.amp = self.amp_q.get_nowait()
        except queue.Empty:
            pass
        try:
            self.peak = self.peak_q.get_nowait()
        except queue.Empty:
            pass

        output = {"amplitude":self.amp, "peak":self.peak}
        print(output)
        return output
